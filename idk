from copy import copy, deepcopy
import sys, os
import numpy as np

# ---- paste your helper functions here ----
# upper_bound, lower_bound, SNH, rowMin, minElement, calcMatrixMinor
# (the versions we wrote that only rely on numpy / builtins)

def _as_list_matrix(A):
    return A.tolist() if isinstance(A, np.ndarray) else A

def upper_bound(A, X):
    M = _as_list_matrix(A)
    total = 0
    for row in M[X:]:
        if not row:
            continue
        total += min(row)
    return total

def lower_bound(A, X):
    M = _as_list_matrix(A)
    return rowMin(M[X:])

def SNH(A):
    M = _as_list_matrix(A)
    total = 0
    for row in M:
        if not row:
            continue
        total += min(row)
    return total

def rowMin(A):
    M = _as_list_matrix(A)
    total = 0
    for row in M:
        if not row:
            continue
        total += min(row)
    return total

def minElement(arr):
    a = arr.tolist() if isinstance(arr, np.ndarray) else arr
    if not a:
        return None, -1
    min_val = a[0]
    min_pos = 0
    for i in range(1, len(a)):
        if a[i] < min_val:
            min_val = a[i]
            min_pos = i
    return min_val, min_pos

def calcMatrixMinor(A, i, j):
    if isinstance(A, np.ndarray):
        return np.delete(np.delete(A, i, axis=0), j, axis=1)
    else:
        minor = []
        for r_idx, row in enumerate(A):
            if r_idx == i:
                continue
            minor.append(row[:j] + row[j+1:])
        return minor

# ---- tests ----

def run_tests():
    # Test matrices (list-of-lists)
    M1 = [
        [6, 4, 2, 5],
        [2, 1, 5, 4],
        [4, 2, 1, 3],
        [5, 3, 3, 2],
    ]
    # Same matrix as numpy array (to verify both code paths work)
    M1_np = np.array(M1, dtype=float)

    # 1) SNH / rowMin (sum of row minima across all rows)
    # row minima: [2, 1, 1, 2] -> sum = 6
    assert SNH(M1) == 6
    assert rowMin(M1) == 6
    assert SNH(M1_np) == 6
    assert rowMin(M1_np) == 6

    # 2) upper_bound / lower_bound (sum of row minima starting at row X)
    # X = 0 -> 6; X = 2 -> rows 2,3 mins: 1+2 = 3
    assert upper_bound(M1, 0) == 6
    assert lower_bound(M1, 0) == 6
    assert upper_bound(M1, 2) == 3
    assert lower_bound(M1, 2) == 3
    assert upper_bound(M1_np, 2) == 3
    assert lower_bound(M1_np, 2) == 3

    # 3) minElement
    arr = [3, 1, 9, -2, 7]
    assert minElement(arr) == (-2, 3)
    arr_np = np.array(arr)
    assert minElement(arr_np) == (-2, 3)
    assert minElement([]) == (None, -1)

    # 4) calcMatrixMinor
    # Remove row 1, col 2 from a 3x3
    M2 = [
        [4, 7, 8],
        [2, 6, 5],
        [3, 1, 9]
    ]
    # Expected minor:
    # delete row index 1 -> [[4,7,8],[3,1,9]]
    # then delete col index 2 -> [[4,7],[3,1]]
    expected_minor = [[4, 7], [3, 1]]
    assert calcMatrixMinor(M2, 1, 2) == expected_minor

    M2_np = np.array(M2, dtype=float)
    minor_np = calcMatrixMinor(M2_np, 1, 2)
    assert isinstance(minor_np, np.ndarray)
    assert minor_np.shape == (2, 2)
    assert minor_np.tolist() == expected_minor

    print("All helper-function tests passed âœ…")

if __name__ == "__main__":
    run_tests()
